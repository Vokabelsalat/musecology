<script>
  function createArrayView(array, idKey, selection) {
    let id = array[idKey].replaceSpecialCharacters() + "ArrayView";
    let arrayStr = "<div class='arrayView' id='" + id + "'>";

    let keyarray = Object.keys(array);
    if (is(selection) && selection.length > 0) {
      keyarray = keyarray.filter((e) => selection.includes(e));
    }

    arrayStr += keyarray
      .map((key) => {
        return "<div>&#8226; " + key + ": " + array[key] + "</div>";
      })
      .join("");

    return [arrayStr + "</div>", id];
  }

  function appendListings(data) {
    let $tableRow = $(this.tableRow);
    let material = this.material;
    let origScientificName = this.scientificName;

    if (data) {
      data.forEach(function (element, index) {
        getOrCreate(
          getOrCreate(getOrCreate(collectedData, material, {}), "listings", {}),
          element["Scientific Name"],
          element
        );

        $tableRow
          .find(".listingsCol")
          .first()
          .find(".scroll")
          .first()
          .append("&#8226; " + element["Scientific Name"] + " (" + element["Listing"] + ")<br>");
      });
    }
  }

  function appendListingHistory(data) {
    let $tableRow = $(this.tableRow);
    let material = this.material;
    let origScientificName = this.scientificName;

    if (data) {
      data.forEach(function (element, index) {
        pushOrCreate(getOrCreate(collectedData, material, {}), "listingHistory", element);

        $tableRow
          .find(".listingHistoryCol")
          .first()
          .find(".scroll")
          .first()
          .append("&#8226; " + element["Appendix"] + " " + element["EffectiveAt"] + "<br>");
      });
    }
  }

  function appendSpecies(data) {
    let $tableRow = $(this.tableRow);
    let material = this.material;
    let origScientificName = this.scientificName;

    if (data) {
      data = data.filter(
        (e) => e.taxonomicStatus === "ACCEPTED" || e.status === "ACCEPTED" || e.status === "SYNONYM"
      );

      data.forEach(function (element, index) {
        getOrCreate(
          getOrCreate(getOrCreate(collectedData, material, {}), "species", {}),
          element["species"],
          element
        );

        $tableRow
          .find(".speciesCol")
          .first()
          .find(".scroll")
          .first()
          .append("&#8226; " + element["species"] + "<br>");
        /*$.post("/queryGBIFspecies/"+ element["Scientific Name"], function(data) {
                      if(data !== undefined) {
                          //appendGBIF(data).bind({"tableRow": $tableRow, "treeName": element["Scientific Name"]});

                          data = JSON.parse(data);

                          if(data.hasOwnProperty("speciesKey")) {
                              let taxon = data["speciesKey"];

                              $.post("/getGBIFsynonyms/"+ taxon,
                                  $.proxy(appendSynonyms, {"tableRow": $tableRow, "scientificName": element["Scientific Name"], material:material}));
                          }
                      }
                  });*/

        /* $.post( "/queryIUCN/"+element["Scientific Name"],
                      $.proxy(appendIUCN, {"tableRow": $tableRow, material: material, scientificName: element["Scientific Name"]})
                  );*/

        /*                if(!getOrCreate(
                      getOrCreate(collectedData, material, {}), "trade", {}).hasOwnProperty(element["species"
                      ])) {
                          $.post( "/getTrade/"+element["Scientific Name"], $.proxy(appendTrade, {"tableRow": $tableRow, "treeName": element["Scientific Name"],  material: material, scientificName: element["Scientific Name"]}));
                  }
                  else {
                  }

                   $.post( "/queryTreeSearchSpeciesWithSciName/"+element["Scientific Name"],
                      $.proxy(appendBGCI, {"tableRow": $tableRow, "treeName": element["Scientific Name"]})
                  );

                  $.post( "/queryThreatSearchWithSciName/"+element["Scientific Name"],
                      $.proxy(appendThreatSearch, {"tableRow": $tableRow})
                  );*/
      });
    }

    /*        let listings = {};

          let speciesView;

          if(getOrCreate(getOrCreate(collectedData, material, {}), "species", {}).length > 1) {

              Object.values(collectedData[material].species).forEach( function(element, index) {
                  listings = pushOrCreate(listings, element.Listing, element);
              });

              let speciesObject = {
              "Name": material,
              "Listing": Object.keys(listings).reduce((s ,e) => { // collect all listing identifiers (e.g. I) and their amount
                  return s + e + " (" + listings[e].length + ")<br>";
              }, "")};

              speciesView = createArrayView(speciesObject, "Name", ["Name", "Listing"])[0];
          }
          else {
              speciesView = Object.values(collectedData[material].species).map(e => {
                  e["All_DistributionFullNames"] = e["All_DistributionFullNames"].replaceAll(",", ", ");
                  return createArrayView(e, "Scientific Name", ["Scientific Name", "Rank", "Listing", "All_DistributionFullNames"])[0];
              })[0];
          }

          if(speciesView !== undefined) {
              $tableRow.find(".speciesCol").first().find(".scroll").first().html(speciesView);
          }*/
  }

  function appendBGCITreeSearch(data) {
    let $tableRow = $(this.tableRow);
    let treeName = this.treeName;
    let material = this.material;
    let scientificName = this.scientificName;

    if (data) {
      let $col = $tableRow.find(".bgciCol").first().find(".scroll").last();
      let map = new BGCIMap("mapid");

      let countries = [];

      function processEntry(e) {
        countries.push(e.country);

        return "&#8226; " + (e.province ? e.country + "/" + e.province : e.country);
      }

      data.forEach(function (element, index) {
        pushOrCreate(getOrCreate(collectedData, material, {}), "trees", element);

        if (index > 0) $col.append("<br>");

        $col.append("<b>" + element.taxon + ":</b><br>");
        $col.append(element.TSGeolinks.map(processEntry).join("<br>") + "<br>");
        map.addTreeCountries(treeName, [...new Set(countries)]);
      });
    }
  }

  function appendSynonyms(data) {
    let $tableRow = $(this.tableRow);
    let scientificName = this.scientificName;
    let material = this.material;

    if (data.length > 0) {
      let mapped = data.map(
        (e) => "&#8226; " + e["canonicalName"] /* + " " + e["taxonomicStatus"]*/
      );

      let $col = $tableRow.find(".synonymCol").first().find(".scroll").first();

      if ($col.text() !== "") {
        $col.append("<br>");
      }

      $col.append("<b>" + scientificName + "</b>:<br>" + mapped.join("<br>"));
    }

    /*if(data.length > 0) {
              $tableRow.find(".synonymCol").first().append("<div><b>"+scientificName + ":</b><br>" + data.join(", ")+"</div>");
  */
    /*            for(let syn of data.values()) {
                  let synSplit = syn.split(" ");
                  $.post( "/getSpecies/"+synSplit[0]+"/"+synSplit[1],
                      $.proxy(appendSpecies, {tableRow: $tableRow, material: material, scientificName: scientificName})
                  );

                  $.post( "/queryIUCN/"+syn,
                      $.proxy(appendIUCN, {"tableRow": $tableRow, material: material, scientificName: scientificName})
                  );

                  $.post( "/queryTreeSearchSpeciesWithSciName/"+syn,
                      $.proxy(appendBGCI, {"tableRow": $tableRow, "treeName": syn})
                  );

                  $.post( "/queryThreatSearchWithSciName/"+syn,
                      $.proxy(appendThreatSearch, {"tableRow": $tableRow})
                  );
              } */
    /* }*/
  }

  function appendThreatSearch(data) {
    let $tableRow = $(this.tableRow);
    let material = this.material;
    let scientificName = this.scientificName;

    console.log("Append Threats!", data, material, scientificName);

    let $col = $tableRow.find(".bgciThreatCol").first().find(".scroll").last();

    $col.append(
      data
        .map((e) => {
          pushOrCreate(getOrCreate(collectedData, material, {}), "threats", e);
          return (
            "&#8226; " +
            e.consAssCategory +
            " – " +
            e.assessmentYear +
            " – " +
            e.threatened +
            " – " +
            e.reference +
            (e.countries ? " - " + e.countries : "")
          );
        })
        .join("<br>")
    );
  }

  function appendTrade(data) {
    let $tableRow = $(this.tableRow);
    let treeName = this.treeName;
    let scientificName = this.scientificName;
    let material = this.material;

    let exportsCountry = {};

    console.log("Append Trades!");

    let collect = false;

    if (
      !getOrCreate(getOrCreate(collectedData, material, {}), "trade", {}).hasOwnProperty(
        scientificName
      )
    ) {
      collect = true;
    }

    data.forEach(function (element, index) {
      exportsCountry = pushOrCreate(exportsCountry, element["Exporter"], element);

      if (collect) {
        pushOrCreate(
          getOrCreate(getOrCreate(collectedData, material, {}), "trade", {}),
          scientificName,
          element
        );
      }
    });

    /*        if(Object.keys(exportsCountry).length > 0) {
              let map = new BGCIMap("mapid");
              map.addExportCountries(treeName, exportsCountry);
          }*/

    $tableRow
      .find(".tradeCol")
      .first()
      .find(".scroll")
      .last()
      .append(data.map((e) => "&#8226; " + e.Year + " " + e.Term).join("<br>"));
  }
</script>