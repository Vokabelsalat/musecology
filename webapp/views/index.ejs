<%- include('./partials/header.ejs') %>

<script>

    function createArrayView(array, idKey, selection) {
        let id = array[idKey].replaceSpecialCharacters() + "ArrayView";
        let arrayStr = "<div id='" + id + "'>";

        let keyarray = Object.keys(array);
        if(is(selection) && selection.length > 0) {
            keyarray = keyarray.filter(e => selection.includes(e))
        }

        arrayStr += keyarray.map(key => {
            return "<div>&#8226; " +key+": "+ array[key] +"</div>";
        }).join("");

        return [arrayStr + "</div>", id];
    }

    function appendSpecies(data) {
        data = JSON.parse(data);
        if(data[0] !== undefined) {
            let $tableRow = $(this);
            let scientificName = data[0]["Scientific Name"];
            let speciesView = createArrayView(data[0], "Scientific Name", ["Scientific Name", "Rank", "Listing", "All_DistributionFullNames"]);
            $tableRow.find(".speciesCol").first().append(speciesView[0]);

            $.post( "/getTrade/"+scientificName, $.proxy(appendTrade, {"tableRow": $tableRow, "treeName": scientificName}));
        }
    }

    function appendTrade(data) {
        let $tableRow = $(this.tableRow);
        let treeName = this.treeName;
        data = JSON.parse(data);

        let exportsCountry = {};

        data.forEach( function(element, index) {
            exportsCountry = pushOrCreate(exportsCountry, element["Exporter"], element);
        });

        if(Object.keys(exportsCountry).length > 0) {
            let map = new BGCIMap("mapid");
            map.addExportCountries(treeName, exportsCountry);
        }

        $tableRow.find(".tradeCol").first().find(".scroll").last().append(data.map(e => "&#8226; " + e.Year + " " + e.Term).join("<br>"));
    }

    function appendBGCI(data) {
        let $tableRow = $(this.tableRow);
        let treeName = this.treeName;
        try {
            if(data != "") {
                data = JSON.parse(data);

                let $col = $tableRow.find(".bgciCol").first().find(".scroll").last();
                
                let map = new BGCIMap("mapid");

                let countries = [];

                function processEntry(e) {

                    countries.push(e.country);

                    return "&#8226; " + (e.province ? e.country+"/"+e.province : e.country);
                }
                
                $col.append("ID:" + data.id + "<br>");
                $col.append(data.TSGeolinks.map(processEntry).join("<br>"));
                map.addTreeCountries(treeName, [ ...new Set(countries) ]);
            }
        }
        catch(err) {
            console.log(err);
        }
    }

    function appendThreatSearch(data) {
        let $tableRow = $(this.tableRow);
            
        data = JSON.parse(data);

        let $col = $tableRow.find(".bgciThreatCol").first().find(".scroll").last();
        
        $col.append(data.map(e => "&#8226; " + e.consAssCategory + " – " + e.assessmentYear + " – " + e.threatened + " – " + e.reference).join("<br>"));
    }

    function appendSynonyms(data) {
        let $tableRow = $(this.tableRow);
        let scientificName = this.scientificName;
        data = JSON.parse(data);
        $tableRow.find(".synonymCol").first().append(data.join(", "));

        for(let syn of data.values()) {
            $.post( "/getTrade/"+syn, $.proxy(appendTrade, {"tableRow": $tableRow, "treeName": scientificName}));

            $.post( "/queryIUCN/"+syn, 
                $.proxy(appendIUCN, {"tableRow": $tableRow})
            );

            $.post( "/queryTreeSearchSpeciesWithSciName/"+syn, 
                $.proxy(appendBGCI, {"tableRow": $tableRow, "treeName": syn})
            );

            $.post( "/queryThreatSearchWithSciName/"+syn, 
                $.proxy(appendThreatSearch, {"tableRow": $tableRow})
            );
        } 
    }

    function appendIUCN(data) {
        let $tableRow = $(this.tableRow);
        data = JSON.parse(data);
        if(data.length > 0) {
            $tableRow.find(".iucnCol").first().find(".scroll").first().append(data.map(e => "&#8226; " + e.year + " " + e.code));
        }
    }

    function appendGBIF(data) {
        let $tableRow = $(this.tableRow);
        let treeName = this.treeName;
        data = JSON.parse(data);
        let taxonKey = data.taxonKey;

        $.post( "/queryGBIF/"+taxonKey, (result) => {
            result = JSON.parse(result);
            let image = "";
            let text = "";
            let coordinates = [];
            for(let entry of result.values()) {
                if(image === "" && entry.hasOwnProperty("media")) {
                    let filter = entry["media"].filter(e => e.format.includes("image"));
                    if(filter.length > 0) {
                        image = filter[0].identifier;
                        /*for(let ident of filter.values()) {
                            $tableRow.find(".imageCol").first().find(".scroll").first().append("<img style='margin-bottom:20px' width='200px' src='"+ image +"'/>");
                        }*/
                    }
                }

                text += entry.datasetName ? "&#8226; " + entry.datasetName + ", " : "";

                if(entry.decimalLatitude !== undefined && entry.decimalLongitude !== undefined) {
                    if(entry.decimalLatitude !== 0 && entry.decimalLongitude !== 0) {
                        coordinates.push([entry.decimalLatitude, entry.decimalLongitude]);
                    }
                }
            }

            let map = new BGCIMap("mapid");
            map.addTreeCoordinates(treeName, coordinates);

            if(image !== "") {
                $tableRow.find(".imageCol").first().find(".scroll").first().append("<img src='"+ image +"'/>");
            }

            if(text !== "") {
                $tableRow.find(".gbifCol").first().find(".scroll").first().append(text);
            }
        });
    }

    function getMainPart(instruments, selectedMainPart=null) {
         $.post( "/getMainPart/"+instruments , function( data ) {
            data = JSON.parse(data);
            let mainPartSelect = $("#mainPartSelect");
            mainPartSelect.closest(".select-wrapper").css("display", "block");
            mainPartSelect.html("");
            mainPartSelect.html(data.map(e => (selectedMainPart != null && selectedMainPart === e.Main_part ? "<option selected='true'>" : "<option>")+e.Main_part+"</option>"));
            mainPartSelect.attr("instruments", instruments);

            if(selectedMainPart) {
                func2($("#mainPartSelect"));
            }
        });
    }

    d3.selection.prototype.moveToFront = function() {
      this.each(function(){
        this.parentNode.appendChild(this);
      });
    };

    function clearTable() {
        $(".tableRow").not(".tableHead").remove();
    }

    function func1(e, selectedMainPart=null){
        let instruments = $(e).val();
        getMainPart(instruments, selectedMainPart);
    }

    function func2(e){
        let mainPart = $(e).val();
        clearTable();
        $.post( "/getMaterial/"+$("#instrumentsSelect").val()+"/"+mainPart, function( data ) {
            data = JSON.parse(data);
            let materialArray = $("#materialArray");
            materialArray.css("display", "inline-block");

            let table = $("#resultTable");

            for(let material of data.values()) {
                let $tableRow = $("<tr class='tableRow'>\
                    <td><div class='tableCell materialCol'/></td>\
                    <td><div class='tableCell speciesCol'/></td>\
                    <td><div class='tableCell synonymCol'/></td>\
                    <td><div class='tableCell tradeCol'><div class='scroll'/></div></td>\
                    <td><div class='tableCell gbifCol'><div class='scroll'/></div></td>\
                    <td><div class='tableCell imageCol'><div class='scroll'/></div></td></td>\
                    <td><div class='tableCell iucnCol'><div class='scroll'/></div></td>\
                    <td><div class='tableCell bgciCol'><div class='scroll'/></div></td>\
                    <td><div class='tableCell bgciThreatCol'><div class='scroll'/></div></td>\
                </tr>");
                //<td><div class='tableCell imageCol'><div style='max-width: 200px; height:8em' class='scroll'/></div></td>\
                let materialView = createArrayView(material, "Trade_name");
                $tableRow.find(".materialCol").first().append(materialView[0]);

                let scientificName = material["Genus"].trim() + " " + material["Species"].trim();

                $.post( "/getSpecies/"+material["Family"]+"/"+material["Genus"]+"/"+material["Species"], $.proxy(appendSpecies, $tableRow));

                $.post( "/getSynonyms/"+scientificName, 
                    $.proxy(appendSynonyms, {"tableRow": $tableRow, "scientificName": scientificName})
                );

                $.post( "/queryIUCN/"+scientificName, 
                    $.proxy(appendIUCN, {"tableRow": $tableRow})
                );

                $.post( "/queryTreeSearchSpeciesWithSciName/"+scientificName, 
                    $.proxy(appendBGCI, {"tableRow": $tableRow, "treeName": scientificName})
                );

                $.post( "/queryThreatSearchWithSciName/"+scientificName, 
                    $.proxy(appendThreatSearch, {"tableRow": $tableRow})
                );

                $.post( "/queryGBIFspecies/"+scientificName, $.proxy(appendGBIF, {"tableRow": $tableRow, "treeName": scientificName}));

                table.append($tableRow);
            }
        });
    }
</script>
<% if (instruments.length > 0) {%> 
    <div class="orchester-wrapper">
        <svg style="border: solid 1px red">
             <filter id="dropshadow" x="-2" y="-2" width="200" height="200">
              <!-- <feGaussianBlur  stdDeviation="1"/> -->
              <feDropShadow stdDeviation="3.0"/>
            </filter>
            <g id="wrapper">
                <g id="selectchart"></g>
            </g>
        </svg>
    </div>
    <div class="select-wrapper">
        <div class="label">Instruments:</div>
        <select id="instrumentsSelect" onchange="<%= 'func1(this);' %>">  
            <% instruments.forEach((instrument, index) => { %>
                <% if (selectedinstrument == instrument.Instruments) { %>
                    <option selected="selected"><%= instrument.Instruments %></option>
                    <script type="text/javascript">func1($("#instrumentsSelect"), "<%= selectedMainPart %>");</script> 
                <% } else{ %>
                    <option><%= instrument.Instruments %>%></option>
                <% } %>
            <%})%>
        </select>
    </div>
    <div class="select-wrapper" style="display: none;">
        <div class="label">Main Parts:</div>
        <select id="mainPartSelect" onchange="<%= 'func2(this);' %>">  
        </select>
    </div>
    <table id="resultTable">
  <tr class="tableRow tableHead">
    <th>Material</th>
    <th>Species</th>
    <th>Synonyms</th>
    <th>Trade</th>
    <th>GBIF</th>
    <th>Image</th>
    <th>IUCN Categories</th>
    <th>TreeSearch</th>
    <th>ThreatSearch</th>
  </tr>
</table>

<div id="mapid"></div>

<script type="text/javascript">

    /*$("#instrumentsSelect").change(function() {
        console.log("CHANGED");
    });*/

    let padding = 20;

    var svgWidth = parseInt($(window).width()) - 2*padding;
    var svgHeight = parseInt(window.innerHeight) - 2*padding;

    d3.select("svg").attr("width", svgWidth).attr("height", svgHeight);

    var animationTime = 1200;

    let positionX = svgWidth / 2;
    let positionY = svgHeight / 2 + 100;

    var container = d3.select("#wrapper");
    var svg_group = d3.select("#selectchart");

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;

      return {
        x: centerX + (radius * Math.cos(angleInRadians)),
        y: centerY + (radius * Math.sin(angleInRadians))
      };
    }

    function getStartAndEnd(path) {
        try {
            let split = path.split(" ");
            return {start: {x: parseInt(split[1]), y: parseInt(split[2])}, end: {x: parseInt(split[9]), y: parseInt(split[10])}};
            // statements
        } catch(e) {
            console.log(e);
            return null;
        }
    }

    function getAngle( x1, y1, x2, y2 ) {
        
        var dx = x1 - x2,
            dy = y1 - y2;
        
        return (-1) * (Math.atan2(dy,dx) * 180 / Math.PI - 180);
    }

    function getDistance(x1, y1, x2, y2) {
        let sum = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
        return Math.sqrt(sum);
    }

    function describeArc(x, y, radius, startAngle, endAngle, direction = 0, withoutM = false){

        var start = polarToCartesian(x, y, radius, endAngle);
        var end = polarToCartesian(x, y, radius, startAngle);

        if(direction === 0) {
            let tmp = start;
            start = end;
            end = tmp;
        }

        var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

        if(withoutM) {
            var d = [
                "L", start.x, start.y, 
                "A", radius, radius, 0, largeArcFlag, direction, end.x, end.y
            ].join(" ");    
        }
        else {
            var d = [
                "M", start.x, start.y, 
                "A", radius, radius, 0, largeArcFlag, direction, end.x, end.y
            ].join(" ");    
        }
        

        return d;       
    }

    function describeLine(x, y, endX, endY, withoutM) {
        if(withoutM)
            return ["L", endX, endY].join(" ");
        else
            return ["M", x, y, "L", endX, endY].join(" ");
    }

    function getGroupAndFileFromID(id) {
        let group = "";

        switch (id) {
            case "streicher":
                group = "String instruments";
                filename = "strings2.svg";
                break;
            case "woodwinds":
                group = "Woodwind instruments (reed driven instruments)";
                filename = "woodwinds2.svg";
                break;
            case "percussion":
                group = "Percussion instruments";
                filename = "percussion2.svg";
                break;
            case "plucked":
                group = "Plucked instruments";
                filename = "plucked2.svg";
                break;
            case "keyboard":
                group = "Keyboard instrument";
                filename = "keyboard2.svg";
                break;
            case "brasses":
                group = null;
                filename = "brasses2.svg";
                break;
            default:
                // statements_def
                break;
        }

        return {group, filename};
    }

    function calcArcLength(r, strokewidth, textlength, angle) {
        return (Math.PI * r) * (angle / 180) - (textlength);
    }

    function getParent(sel) {
        return sel.select(function() { return this.parentNode; });
    }

    function bindMouseOver(element, callback) {
        if(!touchDisplay) {
            element.on("mouseover", callback);
        }
    } 

    let mouseover = function(d) {
        let sel = d3.select(this);
        sel.select(".arc").style("stroke", "rgb(95, 77, 73)").style("stroke-opacity", 0.70).style("stroke-width", 2).style("stroke-linejoin", "round");
        getParent(sel).moveToFront();
        sel.moveToFront();
        /*d3.select(this).classed("blur", true);*/
    };

    let mouseout = function(d)  {
        /*d3.select(this).classed("blur", false);*/
      d3.select(this).select("#" + d3.select(this).attr("id").replace("arcgroup", "") + "path").style("stroke", "initial").style("stroke-opacity", 1.0).style("stroke-width", 1).style("stroke-linejoin", "miter");
    };

    function zoomAndRotate(path, center=false) {
        var bbox = path.node().getBBox();

        let startEnd = getStartAndEnd(path.attr("d"));

        let strokewidth = parseInt(path.attr("arcwidth"));

        let angle = 0.0, distance = 0, toBeScaled = 0;

        if(startEnd && strokewidth) {

            distance = getDistance(startEnd.start.x, startEnd.start.y, startEnd.end.x, startEnd.end.y); //+ strokewidth / 2;

            toBeScaled = (svgWidth / 2) / distance;

            angle = getAngle(startEnd.start.x, startEnd.start.y, startEnd.end.x, startEnd.end.y);
        }
        else {
            distance = bbox.width;

            toBeScaled = (svgWidth / 1.1) / distance;
        }

        var cx=bbox.x+(bbox.width/2),
            cy=bbox.y+(bbox.height/2);   // finding center of element

        let differenceToCenterX = positionX - cx;
        let differenceToCenterY = positionY - cy;

   /*     d3.select("#selectchart").append("rect")
        .style("fill", "blue")
        .attr("width", 3)
        .attr("height", 3)
        .attr("x", cx-1)
        .attr("y", cy-1);*/

/*        d3.select("#selectchart").append("rect")
        .style("fill", "red")
        .attr("width", 3)
        .attr("height", 3)
        .attr("x", svgWidth/2-1)
        .attr("y", svgHeight/2-1);*/

/*        if(isSafari) {
            container.transition().duration(animationTime).attr('transform', 'translate('+ (cx) + ' ' + (cy) +') scale('+ toBeScaled + ' ' + toBeScaled +') rotate('+angle+') translate('+ (-cx) + ' ' + (-cy) +')');
        }
        else {
            container.style("transform-box", "fill-box").style("transform-origin", "center").transition().duration(animationTime).attr('transform', 'scale('+ toBeScaled + ' ' + toBeScaled +') rotate('+angle+') translate('+ (differenceToCenterX) + ' ' + (differenceToCenterY) +')');
        }*/

        let box = container.node().getBBox();
        let boxCenterX = box.x+(box.width/2);
        let boxCenterY = box.y+(box.height);

        let rotateCenterX = positionX;
        let rotateCenterY = positionY;

/*         d3.select("#selectchart").append("rect")
        .style("fill", "red")
        .attr("width", 3)
        .attr("height", 3)
        .attr("x", rotateCenterX-1)
        .attr("y", rotateCenterY-1);

         d3.select("#selectchart").append("rect")
        .style("fill", "purple")
        .attr("width", 3)
        .attr("height", 3)
        .attr("x", differenceToCenterX)
        .attr("y", differenceToCenterY);*/

        var saclestr=toBeScaled+','+toBeScaled;
        var tx=-cx*(toBeScaled-1);
        var ty=-cy*(toBeScaled-1);                        
        var translatestr=tx+','+ty;

        svg_group.transition().duration(animationTime).attr("transform", "\
            translate(" + differenceToCenterX + " " + differenceToCenterY + ") \
            rotate("+angle+" "+cx+" "+cy+") \
            translate("+translatestr+") scale("+saclestr+") \
            ");

/*         d3.select("svg").append("rect")
        .style("fill", "lime")
        .attr("width", 3)
        .attr("height", 3)
        .attr("x", positionX-1)
        .attr("y", positionY-1);*/
    }

    function appendSelectArc(dst, id, text, color, strokewidth, x, y, width, start, end, direction, fontSize, classStr = "") {
        let group = dst.append("g")
        .style("cursor", "pointer")
        .attr("id", id + "arcgroup")
        .attr("name", name)
        .attr("class", "arcgroup");

        let upper = describeArc(x, y, width + strokewidth / 2, start, end, direction);
        let lower = describeArc(x, y, width - strokewidth / 2, start, end, 0, true);

        pathstr = [
            upper,
            lower,
            "Z"
        ].join(" ");

        let path = group.append("path")
        .style("fill", color)
        .style("stroke", "rgb(95, 77, 73)")
        .style("stroke-width", "0.5")
        .attr("id", id + "path")
        .attr("class", "arc")
        .attr("start", start)
        .attr("end", end)
        .attr("radius", width)
        .attr("name", text)
        .attr("arcwidth", strokewidth)
        .attr("d", pathstr);

        path.classed(classStr, true);

        let groupAndFile;
        if(!classStr.includes("subarc")) {
            groupAndFile = getGroupAndFileFromID(id);
            let instrumentGroup = groupAndFile.group;

            width = width + 10;

            $.post( "/group/"+instrumentGroup, function( data ) {
                data = JSON.parse(data);

                let newstroke = strokewidth / (data.length + 2);

                data = data.map(e => e.Instruments).sort((a,b) => {
                    return b.length - a.length;
                });

                let startRadius = width - 10 + strokewidth / 2 - newstroke / 2;

                let newId = (text+instrumentGroup).replaceSpecialCharacters();
                appendSelectArc(group, newId, text, color, newstroke * 2, positionX, positionY, startRadius - (newstroke / 2) , start, end, 1, 10, "subarc heading");
                d3.select("#"+newId+"text").style("text-decoration", "underline");

/*                    d3.select("#"+newId).transition().duration(animationTime * 1.5).style("opacity", 1.0);
                d3.select("#"+newId+"textPath").transition().duration(animationTime * 1.5).style("opacity", 1.0).style("text-decoration", "underline");
*/
                for(let i = 0; i < data.length; i++) {
                    name = data[i];
                    if(name.trim() === "") {
                        name = "General";
                    }

                    newId = (name+instrumentGroup).replaceSpecialCharacters();
                    appendSelectArc(group, newId, name, color, newstroke, positionX, positionY, startRadius - (newstroke) * (i + 2), start, end, 1, 5, "subarc");

                   /* d3.select("#"+newId).transition().duration(animationTime * 1.5).style("opacity", 1.0);
                    d3.select("#"+newId+"textPath").transition().duration(animationTime * 1.5).style("opacity", 1.0);*/
                }
            });
        }


        let pathForText = dst.append("path")
        .style("fill", "none")
        .style("stroke", "none")
        .attr("id", id+"textpath")
        .attr("class", "arcTextPath")
        .attr("start", start)
        .attr("end", end)
        .attr("radius", width)
        .attr("name", text)
        .attr("d", describeArc(x, y, width, start, end, direction));

        let textElement = group
        .append("text")
        .attr("id", id + "text")
        .attr("class", classStr ? classStr + " text" : "text");
        
        let textPath = textElement.append("textPath")
        .style("dominant-baseline", "central")
        .attr("class", "textonpath noselect")
        .attr("xlink:href", "#"+ id+"textpath")
        .attr("font-size", fontSize) 
        .attr("text-anchor", "middle")
        .attr("startOffset", "50%")
        .attr("id", id + "textPath")
        .text(text);

        textElement.classed(classStr, true);

        let pathForIcon = "";

        if(classStr.includes("subarc")) {
            textElement.style("opacity", "0.0").style("display", "none");
            path.style("opacity", "0.0").style("stroke", "none").style("display", "none");
            group.classed("subarc", true);

            bindMouseOver(group, mouseover);
            group.on("mouseout", mouseout)
            .on("click", function(d) {
                //func1($("#instrumentsSelect"), d3.select(this).attr("name"));
                $("#instrumentsSelect").val(d3.select(this).attr("name")).change();
            });

        }
        else {
            pathForIcon = dst.append("path")
            .style("fill", "none")
            .style("stroke", "none")
            .attr("id", id+"textpathIcon")
            .attr("d", describeArc(x, y, width-35, start, end, direction));

            let textElementForIcon = group
            .append("text")
            .attr("id", id + "textIcon")
            .attr("class", classStr ? classStr + " text" : "text");
            
            let textPathForIcon = textElement.append("textPath")
            .style("dominant-baseline", "central")
            .attr("class", "textonpath noselect")
            .attr("xlink:href", "#"+ id+"textpathIcon")
            .attr("font-size", fontSize) 
            .attr("text-anchor", "middle")
            .attr("startOffset", "50%")
            .attr("id", id + "textPath")
            .attr("opacity", "0.0")
            .text(text);

            let filename = groupAndFile.filename;

            if(filename !== "") {
                $.get(filename, function(data){
                    let textBox = textPathForIcon.node().getBBox();
                    var svgNode = d3.select(data.documentElement).select("g");
                    group.append(() => svgNode.node()) ; 
                    let iconBox = svgNode.node().getBBox();

                    let scale = 20 / iconBox.height;

                    let transX = (textBox.x-((iconBox.width*scale)/2) + textBox.width / 2);
                    let transY = (textBox.y + textBox.height);

                    let angle = (start+((end - start)/2) - 360) % 180;

                    cx=iconBox.x+(iconBox.width/2);
                    cy=iconBox.y+(iconBox.height/2);

                    var saclestr=scale+','+scale;
                    var tx=-cx*(scale-1);
                    var ty=-cy*(scale-1);                        
                    var translatestr=tx+','+ty;

                    svgNode.classed("icon", true);

                    svgNode.attr("transform", "\
                    translate("+(textBox.x+(textBox.width/2)) + " " + (textBox.y+(textBox.height/2)) + ") \
                    scale("+scale + " " + scale + ") \
                    rotate("+angle+") \
                    translate("+(-cx) + " " + (-cy) + ") \
                    ");
                });
            }

            //textPath.attr("opacity", "0.0");
            group.moveToFront();
        }

        if(classStr.includes("heading")) {
            group.on("mouseover", null);
            group.on("mouseout", null);
            group.on("click", null);
            group.style("cursor", "initial");
        }
    }

    let selectchart = d3.select("#selectchart");

    let touchDisplay = Boolean(navigator.maxTouchPoints);

    console.log("TOUCH", touchDisplay);

    let margin = 0.5;

    appendSelectArc(selectchart, "streicher", "Strings", "hsl(0, 100%, 60%)", 90, positionX, positionY, 60-margin*5, 90, 270, 1, 12);
    appendSelectArc(selectchart, "percussion", "Percussion", "hsl(0, 100%, 90%)", 70, positionX, positionY, 140, 330-margin, 300+margin, 1, 12);
    appendSelectArc(selectchart, "woodwinds", "Woodwinds", "hsl(0, 100%, 70%)", 70, positionX, positionY, 140, 390-margin, 330+margin, 1, 12);
    appendSelectArc(selectchart, "plucked", "Plucked", "hsl(0, 100%, 100%)", 70, positionX, positionY, 140, 450, 420+margin, 1, 12);
    appendSelectArc(selectchart, "keyboard", "Keyboard", "hsl(0, 100%, 85%)", 70, positionX, positionY, 140, 300-margin, 270, 1, 12);
    appendSelectArc(selectchart, "brasses", "Brasses", "hsl(0, 100%, 75%)", 70, positionX, positionY, 140, 420-margin, 390+margin, 1, 12);
/*
    appendSelectArc(selectchart, "streicher", "Strings", "#FFC914", 90, positionX, positionY, 60-margin*5, 90, 270, 1, 12);
    appendSelectArc(selectchart, "percussion", "Percussion", "#DD1C1A", 70, positionX, positionY, 140, 330-margin, 300+margin, 1, 12);
    appendSelectArc(selectchart, "woodwinds", "Woodwinds", "#008DD5", 70, positionX, positionY, 140, 390-margin, 330+margin, 1, 12);
    appendSelectArc(selectchart, "plucked", "Plucked", "#A4036F", 70, positionX, positionY, 140, 450, 420+margin, 1, 12);
    appendSelectArc(selectchart, "keyboard", "Keyboard", "#14CC88", 70, positionX, positionY, 140, 300-margin, 270, 1, 12);
    appendSelectArc(selectchart, "brasses", "Brasses", "#85D845", 70, positionX, positionY, 140, 420-margin, 390+margin, 1, 12);
*/
    let selected = false;
    let offset = 500;
    let offsetScale = 3.0;

    container.attr("transform", "translate(0 "+ -svg_group.node().getBBox().height/2 +")");
    zoomAndRotate(selectchart, true);

    bindMouseOver(d3.selectAll('g.arcgroup'), mouseover);
    d3.selectAll('g.arcgroup:not(.subarc)')
    .on("mouseout", mouseout)
    .on("click", function(d) {

        let id = d3.select(this).attr("id").replace("arcgroup", "");

        let clickedgroup = d3.select(this);
        let path = clickedgroup.select("#" + id + "path");
        let icon = clickedgroup.select(".icon");

        
        bindMouseOver(d3.selectAll('g.arcgroup:not(.subarc)'), mouseover);

        clickedgroup.on("mouseover", null);

        selectchart.selectAll(".subarc").style("display", "none").transition().duration(animationTime/5).style("opacity", 0.0);
        selectchart.selectAll(".text").style("opacity", 1.0); //.transition().duration(animationTime/2)
        selectchart.selectAll(".icon").style("opacity", 1.0);

        icon.style("opacity", "0.0");
        d3.select("#"+id+"text").style("display", "initial").style("opacity", 0.0);
        clickedgroup.selectAll(".subarc").style("display", "initial").transition().duration(animationTime/5).style("opacity", 1.0);

        setTimeout(function() {
            zoomAndRotate(path);
        });
        }, animationTime/1.5);


   

</script>

<% } %>
 
</div>
</body>
</html>